### Viikkoraportti 6

Tällä viikolla käytin tähän aikaa noin 15 tuntia.

Tällä viikolla olen tehnyt toisen vertaisarvion, päivittänyt dokumentaatiota, parannellut koodiani ja tehnyt suorituskykytestejä. Aloitin viikon suorituskykytestien suorittamista suunnitellen ja toteuttaen sille luokan. Sitten parantelin PairSetiä ja sokkeloiden esitystapaa, ja tein vertaisarvion. Loppuviikon yritin vielä parannella Kruskalia.

Ohjelma on edistynyt tällä viikolla mielestäni melko hyvin. Vaikka varsinaisia uusia ominaisuuksia ei tullut paljoa, niin koodin aiempi toiminnallisuus kehittyi. Ihan ensimmäisenä tällä viikolla lähdin toteuttamaan ohjelmaan Tester-luokkaa, jonka avulla voi tehdä suorituskykytestausta. Käytin ensin vähän aikaa siihen, että mietin, miten tällainen testaus olisi parasta toteuttaa. Päädyin ratkaisuun, jossa jokaiselle algoritmille on olemassa oma testausmetodi, ja sitten on yksi päämetodi, joka ajaa kaikki testausmetodit. Kunkin algoritmin testausmetodissa algoritmi suoritetaan eri kokoisilla sokkeloilla 100 kertaa per koko, ja lasketaan eri kokoisille taulukoille eri algoritmeille keskiarvoajat ja mediaanit. Isoin koko on tällä hetkellä 999x999. Ensin ihmettelin, miten algoritmit voivat olla niin hitaita sokkelolla, jonka koko on alle tuhat, mutta sitten tajusin, että varsinainen taulukkohan sisältää tällöin melkein miljoona alkiota. Laitoin niin, että Tester-metodi ei sisälly testikattavuusraporttiin. Tällä hetkellä Testerin suorituskykydokumentit saa suoritettua vain poistamalla kommentoinnit parista rivistä main-metodin alussa. Se siis onnistuu vain koodiin koskemalla.

Kun olin toteuttanut Tester-luokan ja suoritellut sitä vähän, kävi jälleen selväksi, miten toteutukseni Kruskalista on todella hidas muihin algoritmeihin verrattuna. Niinpä seuraavat muutokset koodiin liittyivät tähän. Yritin etsiä tapoja nopeuttaa Kruskalia. Edistin ohjelmaa niin, että muutin kaikkiin algoritmeihin ja Maze-luokkaan sokkelon esitysmuodon kaksiulotteisesta taulukosta yksiulotteiseksi, jotta se olisi välimuistin kannalta tehokkaampi. Tämä oli iso muutos, ja vaatikin useita muokkauksia kaikkiin algoritmeihin ja niiden testeihin, sekä tietysti Maze-luokkaan ja sen testeihin. Niinpä tähän meni vähän aikaa. Syntyi myös samalla muutemia huolimattomuusvirheitä, kun nyt taulukon koko ei enää kuvannutkaan sokkelon kyljen kokoa. Niinpä jouduin monessa kohtaa koodissa etsimään ja korjaamaan tilanteita, joissa oli vielä jäljellä esim. grid.length, vaikka haluttiin sokkelon kyljen koko n.

Tämän jälkeen jatkoin pohtimista, miten saisin Kruskalia tehokkaammaksi. Totesin, että PairSet, jota Kruskal hyödyntää paljon, oli monilta metodeiltaan hyvin hidas. Niinpä tutkin keinoja nopeuttaa sitä. Ensinnäkin PairSet ei aiemmin tunnistanut kahta kaarta samaksi, jos ne ovat eri päin (eli siis toinen kaari esim. a:sta b:hen ja toinen b:stä a:han). Muokkasin koodia siten, että nyt kahden solmun välinen kaari tunnistetaan samaksi, vaikka kaari olisi toisin päin. Tämä vähentää turhia lisäyksiä ja siten koonkasvatuksia PairSetissä. Tämä muokkaus salli minun nopeuttaa Kruskalia myös niin, että nyt originalEdges-metodissakin tarvitsee yrittää lisätä kaaria PairSetiin vain toisin päin, joten lisäysyrityksiä tulee puolta vähemmän.

Sitten lisäsin PairSettiin toiminnallisuuden, jolla kostruktoriin saa halutessaan antaa joukolle lähtökoon. Sitten lisäsin Kruskaliin toiminnallisuuden, että tarvittan PairSetin aloituskooksi asetetaan aina n * n, missä n on sokkelon kyljen pituus. Niinpä joukkoa ei tarvitse kasvattaa kaaria lisätessä, mikä vähentää huomattavasti joukkotaulukon läpikäyntejä. Tein lisäksi sellaisen muutoksen, että koska PairSetissä tallennettujen alkioiden järjestyksellä ei ole väliä, niin poistometodin ei oikeastaan tarvitse poiston yhteydessä siirtää kaikkia poiston jälkeen tulevia alkioita, kuten se ennen teki. Nyt kaikkien poistettavan jälkeen tulevien alkioiden taaksepäin siirtämisen sijasta poistometodi vain siirtää viimeisen alkion poistetun alkion päälle, ja siirtää viimeistä alkiota merkkaavaa indexiä yhden taaksepäin. Nyt ei tarvitse sitten aina käydä taulukkoa läpi poiston yhteydessä, vaan riittää siirtää yksi alkio.

Tekemällä kaikki nämä muutokset, sain nopeutettua Kruskalia jonkin verran. Viime viikolla Kruskalilla meni n. 20 sekuntia 213x213-kokoisen taulukon generointiin. Nyt sillä meni siihen n. 5,8 sekuntia. Tämä oli kuitenkin edelleen muihin algoritmeihin nähden aivan liian hidas. Pitkän pohtimisen jälkeen päätin kokeilla ratkaisua, jossa en Kruskalissa käytäkään ollekaan PairSettia, vaan korvaan sen käyttämällä taulukkoa ja MersenneTwisteriä. Näin sain tehostettua Kruskalia niin, että sillä meni 213x213-kokoisen taulukon generoimiseen enää 20 ms.

Ohjelmaan tuli myös pieniä käyttäliittymämuutoksia vertaisarvioinnissa saamieni hyvien kommenttien ansiosta. Muokkasin graafista käyttöliittymää niin, että se mahtuu nyt paremmin myös vähän pienemmille näytöille (pienensin muun muassa sokkelon ruutujen kokoa). Lisäksi tein niin, että sokkelon generointiin mennyt aika jää näkymiin myös ratkaisualgoritmien ajamisen jälkeen.

Tein suorituskykytestien pohjalta kuvaajan algoritmien nopeuksista ja lisäsin testausdokumenttiin suoritusaikojen mediaaneja eri algoritmeille eri kokoisilla taulkoilla. Lisäsin myös vähän niihin liittyvää kuvailua ja analyysia.

Tällä viikolla opin jotain koodin tehokkuuden parantamisesta. Opin kiinnittämään enemmän huomiota myös algoritmin käyttämien tietorakenteiden toteutusseikkojen vaikutuksiin. Minulla on nyt parempi käsitys siitä, miten käsitellä tehokkaammin taulukkoa, kun kyseessä on joukko. En myöskään ennen ollut tajunnut, että moniulotteisten taulukoiden muuttaminen yksiulotteisiksi nopeuttaa toimintaa tiedon paikallisuuden periaatteen takia. Tämä oli minusta tosi mielenkiintoista.

Vaikeuksia tällä viikolla tuotti se, etten ole varma, minkä verran suorituskykytestausta ja missä muodossa on hyvä. Lisäksi iso ongelma ja vaikeus oli Kruskalin nopeuttaminen. Se onneksi viimein ratkesi ottamalla PairSetin pois algoritmista. ChainSolver kuitenkin on edelleen melko hidas.

#### Kysymyksiä

Onko tekemäni suorituskykytestaus hyvä? Testien ajaminen vie omalla koneella  yhteensä 9 min. Onko jotain, mitä pitäisi testata erilailla/lisää? Onko jotain kuvaajatyyppejä, joita olisi hyvä lisätä testidokumenttiin?

Pitäisikö minun toteuttaa Tester-luokan suorituskykytestien ajaminen niin, että sitä varten ei tarvitsisi koskea koodiin? Vai riittääkö, että suorituskykytestauksen saa ajettua niin, että käy poistamassa main-metodin alussa parilta riviltä kommentoinnin?

#### Seuraavaksi

Haluaisin tehdä ChainSolverista nopeamman. ChainSolver on nyt melko hidas, ja uskon, että sitä olisi mahhdollista tehostaa. Aion myös hioa vielä dokumentaatiota. Jatkan suorituskykytestausta ainakin siinä mielessä, että tutkin, voisinko saada ChainSolveria ja muita algoritmeja nopeammiksi. Mikäli suortuskykytestauksessa ja testausdokumentissa on vielä puuttuvia elementtejä, niin lisäilen myös niitä. Pitää myös siistiä PairSet-luokkaa nyt, kun sitä ei enää käytetä kaariin. Mahdollisesti sen voisi poistaa kokonaan, jos myös parien käsittelyyn joukkona on nopeampi keino.
