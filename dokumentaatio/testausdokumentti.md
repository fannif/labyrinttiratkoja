## Testausdokumentti

Tähän mennessä työ ei ole valmis, joten kaikkea testailua ei ole vielö tehty. Tähän mennessä on kuitenkin kirjoitettu yksikkötestejä sekä testailtu toimintaa ja suoritusnopeuksia manuaalisesti graafisen käyttöliittymän kautta. Olen vertaillut nopeuksia, ja pohtinut mistä niiden erot johtuvat.

Yksikkötestejä olen kirjoittanut projektiin alusta asti. Pyrkimyksenä on ollut pitää kaikkien sovelluslogiikan luokkien testikattavuus hyvänä. Olen pyrkinyt testaamaan erityisesti sitä, että luokkien ydintoiminnallisuus toimii niin, kuin sen minun käyttötarkoituksessani ja siinä ilmenevissä mahdollisissa tilanteissa pitäisikin. Esimerkiksi generointialgoritmeille olen aina rakentanut testit, jotka varmistavat, että generoitu labyrintti on mahdollista ratkaista, ja että seiniä on oikeissa paikoissa. Ratkaisualgoritmeille puolestaan olen aina testannut, että ne oikeasti pääsevät maaliin asti.

Yksikkötestien ohella olen tehnyt alusta asti jatkuvaa manuaalista testausta graafisesta käyttöliittymästä. Siksi toteutinkin ohjelmaan heti graafisen käyttöliittymän. Olen tarkastellut sieltä, millaisia labyrintteja algoritmini luovat: ovatko ne järkevän näköisiä, tarpeeksi monimutkaisia ja ratkaistavissa. Siinä samalla olen myös heti huomannut, jos seiniä on jostain syystä väärässä paikassa. Ratkaisualgoritmien yhteydessä olen pystynyt graafisesta käyttöliittymästä tarkastelemaan niiden reittejä. Olen erikokoisilla sokkeloilla valmistanut, että ratkaisupolku menee maaliin asti ja on yhtenäinen, eikä mene seinien läpi.

Myöhemmin lisäsin projektiini myös mahdollisuuden tarkastella algoritmien suoritusaikoja käyttöliittymästä. Sen jälkeen olenkin tarkkaillut myös nopeutta algoritmeja toteuttaessani ja muokatessani. Olenkin testaillut generoida labyrintteja eri algoritmeilla ja tarkastellut niiden suoritusaikoja. Vastaavasti olen tarkastellut ratkaisualgoritmien suoritusaikoja, ja siten saanut käsitystä niiden nopeuksien suhteista sekä siitä, millaisten labyrinttien ratkaisussa kukin niistä on hyvä. Tästä olen saanut paremman käsityksen algoritmien heikkouksista ja olen päässyt pohtimaan, miten niitä voisi mahdollisesti parantaa.

Aluksi käytin yleensä syötteenä vertailussa 51x51-kokoista labyrinttia. Se on tarpeeksi iso, että muodostetuissa labyrinteissa, reiteissä ja suoritusajoissa näkyy jo algoritmikohtaisia eroja ja ominaispiirteitä, mutta ei kuitenkaan niin iso, että sen mahtumisessa näytölle tai käsittelyssä olisi ongelmia. Algoritmeja toteuttaessa ja kehittäessä olen usein aluksi käyttänyt ihan pieniä labyrinttejä, kuten 15x15-kokoisia. Näin minun on ollut helpompi simuloida itse päässä algoritmin toimintaa tällaisessa labyrintissa ja löytää syitä virhetilanteille. Kun olen sitten tällä tavalla testaamalla saanut virheitä karsittua pois, niin olen aina edennyt isompaan labyrinttiin. Pienillä labyrinteilla oli hyvä kehitysvaiheessa huomata, mitä yhteistä virheisiin johtavilla labyrinteilla oli, ja siten päätellä, mistä ongelma voisi johtua.

Manuaalisessa suorituskykytestauksessa huomasin, että käyttöliittymä oli ohjelman hitain elementti. Labyrintin kuvan generoimiseen menee itse algoritmien ajamiseen suhteessa todella paljon aikaa. Tämä teki isojen labyrinttien käsittelystä käyttöliittymän kautta kankeaa. Lisäsin siis käyttöliittymään mahdollisuuden käsitellä isompia labyrintteja ilman, että niistä näytetään kuvaa, jolloin toiminta nopeutui huomattavasti. Tätä ominaisuutta hyödyntäen on tehty suorituskykytestausta generoimalla ja ratkaisemalla labyrintteja vuorotellen eri algoritmilla. Testauksessa kävi ilme, että Kruskalin algoritmi on huomattavasti muita algoritmeja hitaampi. Kun käsitellään 213*213-kokoista sokkeloa, niin Kruskalin algoritmilla menee noin 20 sekuntia, kun taas Sidewinderilla menee noin 30 millisekuntia ja rekusriivisella jakoalgoritmilla yleensä reilusti alle kymmenen millisekuntia. Testatessani olen huomannut, että vielä esimerkiksi 3003*3003-kokoisen sokkelon generointiin rekursiivisella jakoalgoritmilla menee reilusti alle puoli sekuntia. Tästä huomaa hyvin Kruskalin suheettlisen hitauden, kun se on paljon pienempienkin sokkeloiden tapauksessa huomattavasti tätä hitaampi.

Ratkaisualgoritmeista Wall Follower on nopein. Sillä menee isossakin labyrintissa yleensä alle 3 millisekuntia. Lyhyimpien polkujen algoritmilla menee yleensä alle 10 millisekuntia. Ratkaisualgoritmeista hitain on ketjualgoritmi, jolla menee saman labyrintin ratkaisemiseen yleensä 5 - 10 kertaa kauemmi kuin lyhyimpien polkujen algoritmilla. Testauksessa kävi myös ilmi, että ratkaisijoista Wall Followerin löytämät reitit ovat yleensä pisimpiä ja lyhyimpien polkujen algoritmin löytämät selvästi lyhyimpiä.

Tekemäni yksikkötestit on helppo toistaa. Ne voi ajaa terminaalista, jolloin niistä saa myös raportin. Raportin voi generoida lataamalla projektin GitHubista ja menemällä sitten ladattuun kansioon LabyrinthSolver-hakemiston sisälle. Raportin generoimiseksi suoritetaan hakemiston sisällä ollessa Linuxilla komento ’mvn test jacoco:report’. Raportti kertoo testien rivi- ja haaraumakattavuuden. Kattavuusraportti löytyy tiedostosta target/site/jacoco/index.html.

Tekemäni manuaalisen testauksen voi toistaa graafisen käyttöliittymän kautta. Tämä tapahtuu käynnistämällä ohjelma, ja sitten klikkailemalla vuorotellen eri generointi- ja ratkaisumenetelmien nappeja isojen ja pienien labyrinttien kohdalla, jolloin algoritmit suoritetaan. Tässä kannattaa ottaa huomioon, että ensimmäisillä suorituskerroksilla (varsinkin ihan ensmmäisellä napinpainalluksella) algoritmit toimivat paljon hitaammin kuin normaalisti. Kun nappeja painelee pari kertaa, niin saa oikeasti vertailukelpoista testidataa. Isoa labyrinttia tutkiessa ja Kruskalia käytettäesse joutuu odottamaan, koska se on hidas.
